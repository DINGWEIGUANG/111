# 01.数组

## 1. 基础概念
###1.1 数组定义

**数组（Array）**：一种用于存储相同类型的数据元素的数据结构；也是一种线性数据结构，这意味着数组的元素按照顺序排列，通常在内存中是连续存储的。数组具有以下特点：

***（1）有序性***：
数组中的元素是按照一定的顺序排列的，每个元素都有一个唯一的索引，可以通过索引访问。
***（2）同质性***：
数组中的所有元素都具有相同的数据类型。比如字符类型 char、整型类型 int等。
***（3）固定大小***：
通常在创建数组时需要指定数组的大小，一旦确定，数组的大小一般不会在运行时改变。这也意味着要添加或删除元素，通常需要创建一个新的数组。
***（4）连续存储***：
在内存中，数组通常是连续存储的，这有助于快速访问数组元素，但也可能导致内存浪费，因为数组的大小在创建时已经确定。
***（5）快速访问***：
由于数组中的元素是按索引排列的，因此可以通过索引快速访问特定元素，具有常量时间复杂度（O(1)）的访问效率。

还可以从两个方面来解释一下数组的定义：
**线性表**：线性表就是所有数据元素排成像一条线一样的结构，线性表上的数据元素都是相同类型，且每个数据元素最多只有前、后两个方向。数组就是一种线性表结构，此外，栈、队列、链表都是线性表结构。
**连续的内存空间**：线性表有两种存储结构：**顺序存储结构** 和 **链式存储结构**。其中，「顺序存储结构」是指占用的内存空间是连续的，相邻数据元素之间，物理内存上的存储位置也相邻。数组也是采用了顺序存储结构，并且存储的数据都是相同类型的。

以字符数组为例，数组的存储方式如下图所示：

![sizeof整型结果](https://pic.nihaocoding.com/202311081654129.png)

###1.2 如何随机访问数据元素
数组的一个最大特点是：**可以进行随机访问**。即数组可以根据下标，直接定位到某一个元素存放的位置。
那么，计算机是如何实现根据下标随机访问数组元素的？

计算机给一个数组分配了一组连续的存储空间，其中第一个元素开始的地址被称为 **首地址**。每个数据元素都有对应的下标索引和内存地址，计算机通过地址来访问数据元素。当计算机需要访问数组的某个元素时，会通过 **寻址公式** 计算出对应元素的内存地址，然后访问地址对应的数据元素。

寻址公式如下：**下标 i 对应的数据元素地址 = 数据首地址 + i × 单个数据元素所占内存大小**。

###1.3 多维数组
多维数组是包含两个或多个维度的数组，通常用于表示复杂的数据结构，例如表格、矩阵、图像和多维数据。
####（1）二维数组：
二维数组是一个由 m 行 n 列数据元素构成的特殊结构，其本质上是以数组作为数据元素的数组，即 「数组的数组」。二维数组的第一维度表示行，第二维度表示列。

![二维数组](https://pic.nihaocoding.com/202311131012038.png)
```c
int matrix[3][4] = {{1, 2, 3, 4},       // {1, 2, 3, 4}为第一个一维数组
                    {5, 6, 7, 8},       // {5, 6, 7, 8}为第二个一维数组
                    {9, 10, 11, 12}};   // {9, 10, 11, 12}为第三个一维数组

```
####（2）更高维数组：
这里以三维数组为例：
三维数组是一种更高维度的数组，它是由多个二维数组组成的数据结构。
```c
int cube[2][3][4] = {
        // 第一个二维数组
        {{1, 2, 3, 4},      // 第一个一维数组
         {5, 6, 7, 8},      // 第二个一维数组
         {9, 10, 11, 12}},  // 第三个一维数组
        // 第二个二维数组
        {{13, 14, 15, 16},  // 第一个一维数组
         {17, 18, 19, 20},  // 第二个一维数组
         {21, 22, 23, 24}}  // 第三个一维数组
};
```
## 2. 数组的基本操作
数据结构的操作一般涉及到**增、删、改、查**共 4种情况，下面我们一起来看一下数组的这 4种基本作。
###2.1 访问元素
访问数组中第 i 个元素：
（1）只需要检查i的范围是否在**合法的范围区间**，即 0 < i < len(nums) - 1。超出范围的访问为**非法访问**。
（2）当位置合法时，**由给定下标得到的元素的值**。
```C
#include <stdio.h>

int nums[5]={6,7,8,9,10};
int i=0;

int access_Array(int i)// 从数组 nums 中读取下标为 i 的数据元素值
{
        if(i>=0 && i < 5)
        {
                printf("%d",nums[i]);   
                return 0;
        }
        else
                return -1;
}

int main(){
    access_Array(1);    // 访问并输出第二个元素的值
    return 0;
}
```
访问数组元素的操作不依赖于数组中元素个数，因此访问数组元素的**时间复杂度为O(1)**。

###2.2 查找元素
####查找数组中元素值为value
（1）建立一个基于下标的循环，每次将查找的值value与当前数组元素nums[i]进行比较。
（2）在找到元素的时候返回元素下标。
（3）遍历完找不到时返回一个特殊值（例如-1）。
```c
#include <stdio.h>

int nums[5]={6,7,8,9,10};
int i=0;
int value=8;

int find_Array(int val)     // 查找数据是否存在于数组中
{
        while(i < 5)
        {
                if(nums[i] == value)
                {
                        return i;   // 查找到，返回元素下标
                }
                i++;
        }
        return -1;          // 未查找到，返回特殊值-1   
}

int main(){
    int num = find_Array(value);
    printf("%d",num);       // 打印查找结果（下标或-1）      
}
```
在 **查找元素** 的操作中，如果数组无序，那么我们只能通过将value与数组中的数据元素逐一对比的方式进行查找，也称为线性查找。而线性查找操作依赖于数组中元素个数，因此，查找元素的时间复杂度为O(n)。
###2.3 插入元素
插入元素操作有两种方式：**在数组尾部插入元素** 和 **在数组第i个位置上插入元素** 。
####在数组尾部插入元素：
（1）如果数组容量不满，则直接把value放在数组尾部的空闲位置，并更新数组的元素计数值。
（2）如果数组容量满了，则插入失败。
![在数组尾部插入元素](https://pic.nihaocoding.com/202311131153677.png)
```c
#include <stdio.h>

int main() {
    int arr[7] = {23, 43, 67, 89, 898,23,0};
    int size = 6;  // 数组存放数据的数量

    int value = 6;  // 要插入的值

    if (size < 7) {
        arr[size] = value;  // 在数组尾部插入值
        size++;  // 更新数组大小
        printf("插入后的数组：\n");
        for (int i = 0; i < size; i++) {
            printf("%d ", arr[i]);
        }
    } else {
        printf("数组已满，无法插入新元素。\n");
    }

    return 0;
}
```
**在数组尾部插入元素** 的操作不依赖于数组个数，因此，时间复杂度为O(1);
####在数组第i个位置上插入元素:
（1）先检查插入下标i是否合法，即0 < i < len(nums)。
（2）确定合法位置后，一般情况下第i个位置上已经有数据了（除非i == len(nums)），要把第i~len(nums)-1位置上的元素依次向后移动。
（3）然后再在第i个元素位置赋值为value，并更新数组的元素计数值。
![在数组第i个位置上插入元素](https://pic.nihaocoding.com/202311131155229.png)
```c
#include <stdio.h>
#define MAX_SIZE 100

int main() {
    int nums[MAX_SIZE] = {1, 2, 3, 4, 5};
    int len = 5;        // 数组当前大小
    int i = 2;          // 插入的位置
    int value = 10;     // 要插入的值

    if (i < 0 || i > len) {
        printf("插入位置不合法\n");
    } else {
        if (len == MAX_SIZE) {
            printf("数组已满，无法插入新元素\n");
        } else {
            for (int j = len; j > i; j--) {
                nums[j] = nums[j - 1];  // 向后移动元素
            }
            nums[i] = value;  // 在第i个位置上赋值为value
            len++;  // 更新数组的大小
            printf("插入后的数组：\n");
            for (int k = 0; k < len; k++) {
                printf("%d ", nums[k]);
            }
        }
    }
    return 0;
}
```
在数组元素中位置插入元素 的操作中，由于移动元素的操作次数**跟元素个数有关**，因此，在数组元素中间位置插入元素的**最坏和平均时间复杂度**都是O(n)。
###2.4 改变元素值
####将数组中第i个元素值改为value：
（1）需要先检查i的范围是否在合法的范围区间，即0 ≤ i ≤ len(nums) -1。
（2）然后将第i个元素值赋值为value。
![改变元素值](https://pic.nihaocoding.com/202311131432216.png)
```c
#include <stdio.h>
#define MAX_SIZE 100

int main() {
    int nums[MAX_SIZE] = {1, 2, 3, 4, 5};
    int len = 5;        // 数组当前大小
    int i = 2,n = 0;    // 改变的位置的下标
    int value = 10;     // 要改变的值

    if (i < 0 || i > len) {
        printf("改变位置不合法\n");
    } else {
        nums[i] = value;
        for(n=0;n<5;n++)
        {
                printf("%d",nums[n]);
        }
    }
    return 0;
}
```
改变元素值 的操作跟访问元素操作类似，访问操作不依赖于数组中元素个数，因此，改变元素 的**时间复杂度**为**O(1)**。
###2.5 删除元素
删除元素一般有三种情况：**删除数组尾部元素**、**删除数组第i个位置上的元素**、**基于条件删除元素**。
####删除数组尾部元素
（1）只需将元素计数值减一即可。
![删除数组尾部元素](https://pic.nihaocoding.com/202311131443854.png)
```c
#include <stdio.h>

void deleteElement(int nums[], int* size) {
    if (*size <= 0) {
        printf("数组为空，无法删除元素。\n");
        return;
    }

    // 将数组的大小减1
    *size = *size - 1;
}

int main() {
    int nums[] = {1, 2, 3, 4, 5};
    int size = sizeof(nums) / sizeof(nums[0]);

    printf("原始数组：");
    for (int i = 0; i < size; i++) {
        printf("%d ", nums[i]);
    }
    printf("\n");

    // 删除数组尾部的元素
    deleteElement(nums, &size);

    printf("删除后的数组：");
    for (int i = 0; i < size; i++) {
        printf("%d ", nums[i]);
    }
    printf("\n");

    return 0;
}
```
删除数组尾部元素 的操作，不依赖于数组中的元素个数，因此，删除数组尾部元素 的时间复杂度为O(1)。
####删除数组第i个位置上的元素
（1）先检查下标i是否合法，即 0 ≤ i ≤ len(nums) - 1。
（2）如果下标合法,则将第i+1个位置到第len(nums) - 1位置上的元素依次向左移动。
（3）删除后修改数组的元素计数值。
![删除数组第i个位置上的元素](https://pic.nihaocoding.com/202311131506954.png)
```c
#include <stdio.h>

void deleteElement(int arr[], int len, int i) {
    // 检查下标是否合法
    if (i < 0 || i >= len) {
        printf("Invalid index!\n");
        return;
    }

    // 移动元素
    for (int j = i; j < len - 1; j++) {
        arr[j] = arr[j + 1];
    }

    // 修改数组的元素计数值
    len--;

    // 输出删除元素后的数组
    printf("Updated array: ");
    for (int j = 0; j < len; j++) {
        printf("%d ", arr[j]);
    }
    printf("\n");
}

int main() {
    int nums[] = {1, 2, 3, 4, 5, 6};
    int len = sizeof(nums) / sizeof(nums[0]);

    // 删除下标为2的元素
    int index = 2;
    deleteElement(nums, len, index);

    return 0;
}
```

####基于条件删除元素
该操作一般不给定被删元素的位置，而是给出一个条件要求删除满足条件的（一个、多个或所有）元素。这类操作也是通过循环检查元素，查找到元素后将其删除。

基于条件删除元素 的操作同样涉及移动元素，而移动元素的操作次数跟元素个数有关，因此，「基于条件删除元素」的最坏和平均时间复杂度都是 O(n)。

## 3. 常用算法
###3.1 搜索和查找算法
####顺序查找
1、一种简单直接的搜索算法，用于在数组或列表中查找特定值。基本思想是**逐个比较数组中的元素**，直到找到目标值或遍历完整个数组。

2、**基本步骤**：
（1）从数组的第一个元素开始，依次遍历每个元素。
（2）比较当前元素与目标值：
        如果当前元素等于目标值，返回该元素的索引（位置）。
        如果当前元素不等于目标值，则继续遍历下一个元素。
（3）如果遍历完整个数组后仍未找到目标值，则返回一个特定的标识，如-1，表示目标值不存在于数组中。
```c
int linearSearch(int array[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (array[i] == target) {
            return i;  // 返回目标值的索引
        }
    }
    return -1;  // 目标值不存在，返回 -1
}
```
3、特点
（1）**简单易懂**：顺序查找是一种基本的搜索算法，其思想直观且易于理解。它通过顺序地遍历待搜索的数据集，逐个比较目标值和数组中的元素，直到找到目标值或遍历完整个数据集为止。

（2）**适用范围广**：顺序查找适用于各种数据结构，包括数组、链表等，在任何情况下都可以使用。它不要求待搜索的数据集是有序的，因此适用性很广。

（3）**实现简单**：顺序查找的实现非常简单，只需要一个循环来逐个遍历数据集，并进行比较操作。由于实现简单，适用性广泛，因此在某些小规模或者对效率要求不高的场景中仍然具有一定的优势。

（4）**时间复杂度相对高**：顺序查找的平均时间复杂度为 O(n)，其中 n 是待搜索数据集的长度。这意味着其性能随着数据规模的增加而线性增长，因此在大规模数据上其效率相对较低。

（5）**排序无关性**：顺序查找不依赖于数据集是否有序，因此可以直接应用于无序数据集的搜索。这使得顺序查找在一些特定情况下具有一定的灵活性，不要求事先对数据集进行排序操作。

####二分查找
1、也称为**折半查找**，是一种高效的查找算法。它适用于有序数组或有序列表，并通过将查找范围分成两部分来迅速缩小查找范围，从而快速定位目标值。

2、**基本步骤**：
（1）确定要查找的区间的起始位置（通常是整个数组的起始位置）和结束位置（通常是整个数组的末尾位置）。

（2）计算出中间位置（取起始位置和结束位置的中间值），并将中间位置的元素与目标值进行比较。

（3）如果中间位置的元素等于目标值，则查找成功，返回该元素的索引。

（4）如果中间位置的元素大于目标值，则将结束位置调整为中间位置的前一个位置，即缩小查找范围到左半部分。

（5）如果中间位置的元素小于目标值，则将起始位置调整为中间位置的后一个位置，即缩小查找范围到右半部分。

（6）重复步骤2至5，直到找到目标值或者查找范围为空（起始位置大于结束位置）为止。
```c
int binarySearch(int array[], int low, int high, int target) {
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (array[mid] == target) {
            return mid;  // 返回目标值的索引
        } else if (array[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;  // 目标值不存在，返回 -1
}
```
3、特点
（1）**高效性**：二分查找是一种高效的搜索算法，其时间复杂度为 O(log n)，其中 n 是待搜索数组的长度。相比于线性查找的时间复杂度 O(n)，二分查找在大规模数据上具有明显的效率优势。

（2）**适用条件**：二分查找要求待搜索的数组必须是有序的。只有在有序数组中才能应用二分查找算法进行快速定位目标元素。

（3）**分而治之**：二分查找采用分而治之的思想，通过比较中间元素与目标值的大小关系，将搜索范围缩小一半。这种分治的策略使得每一步的搜索都能将搜索范围减半，从而快速地逼近目标元素。

（4）**简单易实现**：二分查找的逻辑相对简单，易于实现。它通常采用迭代或递归的方式来实现，代码结构清晰且易于理解。

（5）**不适用于非随机访问数据结构**：尽管二分查找在数组等连续存储结构上非常高效，但它不适用于链表等非随机访问的数据结构。因为链表等非随机访问结构无法直接通过下标访问元素，而二分查找依赖于对中间元素的快速访问。

###3.2 排序算法
####冒泡排序
1、一种简单且经典的排序算法，它会多次遍历待排序的序列，每次遍历都会比较相邻的元素，并根据需要交换它们的位置。通过多次遍历和交换，较大（或较小）的元素会逐渐“浮”到序列的顶端（或底端），从而实现排序的目的。

2、**基本步骤**：
（1）从序列的第一个元素开始，依次比较相邻的两个元素，如果顺序不符合排序规则（比如要进行升序排序，则前面的元素大于后面的元素），则交换它们的位置，使得较大的元素向序列的尾部移动。

（2）继续对序列中的每一对相邻元素进行相同的操作，直到遍历完整个序列。这样一次遍历之后，序列中最大的元素就会“沉”到序列的末尾。

（3）重复以上步骤，但不包括已经排好序的部分（即每一轮遍历都减少一次对比次数），直到整个序列都变得有序。
```c
void bubbleSort(int array[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (array[j] > array[j + 1]) {
                // 交换 array[j] 和 array[j + 1] 的位置
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```
3、特点
（1）**简单易懂**：冒泡排序是一种基本的排序算法，其思想直观且易于理解。它只涉及相邻元素之间的比较和交换操作。

（2）**稳定性**：冒泡排序是一种稳定的排序算法，即相等元素的相对顺序不会发生改变。在比较相邻元素时，只有当它们的顺序不符合排序规则时才进行交换，因此相等元素的顺序不会被改变。

（3）**原地排序**：冒泡排序是一种原地排序算法，即不需要额外的辅助空间来进行排序操作。它只需要一个常数级别的额外空间用于交换元素。

（4）**时间复杂度**：冒泡排序的平均时间复杂度为 O(n^2)，其中 n 是待排序序列的长度。在最好情况下，即序列已经有序，冒泡排序的时间复杂度可以降低到 O(n)。但在最坏情况下，即序列逆序，需要进行 n-1 轮遍历和比较操作，因此时间复杂度达到 O(n^2)。

（5）**效率较低**：由于冒泡排序的时间复杂度较高，尤其是在大规模数据上，它的效率相对较低。对于大型数据集，通常选择其他更高效的排序算法，如快速排序、归并排序等。

####快速排序
1、一种基于**分治思想**的排序算法。它通过选择一个基准元素，将待排序数组分割成两个子序列，其中一个子序列中的元素都小于等于基准元素，另一个子序列中的元素都大于等于基准元素。然后对这两个子序列分别递归地应用快速排序算法，直到子序列长度为1或0，最终将得到一个有序数组。

2、**基本步骤**：
（1）选择基准元素（pivot），可以选择数组的第一个元素、最后一个元素或随机选择。

（2）将数组划分成两个子序列，一个序列包含小于等于基准元素的元素，另一个序列包含大于等于基准元素的元素。

（3）对这两个子序列分别递归地应用快速排序算法，直到子序列长度为1或0。

（4）合并已排序的子序列，得到最终的有序数组。
```c
// 用于交换两个元素的位置
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 用于确定基准元素的位置并进行分割操作
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准元素
    int i = (low - 1);  // 定义i为较小元素的索引

    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// 用于递归地对子序列应用快速排序算法
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // 获取分割点的索引
        int pi = partition(arr, low, high);

        // 对分割点左侧的子序列递归调用快速排序
        quickSort(arr, low, pi - 1);
        // 对分割点右侧的子序列递归调用快速排序
        quickSort(arr, pi + 1, high);
    }
}

```
3、特点
（1）**高效性**：快速排序是一种高效的排序算法，其平均时间复杂度为O(nlogn)，其中n是待排序数组的长度。相比于其他常见的排序算法，如冒泡排序、插入排序，快速排序通常具有更好的性能。

（2）**原地排序**：快速排序可以在原始数组上进行排序，不需要额外的空间。它通过交换元素的位置实现排序，因此空间复杂度为O(1)，是一种原地排序算法。

（3）**不稳定性**：快速排序是一种不稳定的排序算法，即在排序过程中相等元素的相对顺序可能会发生变化。这是因为快速排序是通过交换元素实现分割的，而不是通过比较和交换。

####归并排序
1、一种基于**分治思想**的排序算法。它采用分而治之的策略，将待排序数组分割成多个子序列，然后对这些子序列递归地进行排序，最后将已排序的子序列合并成一个有序的序列。

2、**基本步骤**：
（1）分割：将待排序数组分割成两个大致相等的子序列，直到子序列长度为1。

（2）排序：对每个子序列进行递归排序，直到所有子序列都变成有序的序列。

（3）合并：合并两个有序子序列，直至最终得到一个完全有序的数组。
```c
// 用于合并两个有序子序列
void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 用于递归地对子序列应用归并排序算法
void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
```
3、特点
（1）**稳定性**：归并排序是一种稳定的排序算法，即在排序过程中相等元素的相对顺序不会发生变化。
（2）**高效性**：归并排序的时间复杂度为O(nlogn)，其中n是待排序数组的长度。它的性能相对稳定，不受输入数据的影响。
（3）**非原地排序**：归并排序通常需要额外的空间来存储临时的中间结果，在最坏情况下需要O(n)的额外空间。因此，它是一种非原地排序算法。

####插入排序
1、一种通过构建有序序列，对未排序数据逐个插入已排序序列的排序算法。对于每个未排序的元素，在已排序的部分找到合适的位置并插入，直至整个序列有序。

2、**基本步骤**：
（1）从第一个元素开始，该元素可以认为已经被排序。

（2）取出下一个元素，在已经排序的元素序列中从后向前扫描。

（3）如果已排序的元素大于新元素，则将已排序的元素向后移动一个位置。

（4）重复步骤3，直至找到已排序的元素小于或等于新元素的位置。

（5）将新元素插入到该位置。

（6）重复步骤2~5，直至整个序列有序。

```c
// 用于对数组进行插入排序
void insertionSort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
```
3、特点
（1）**稳定性**：插入排序是一种稳定的排序算法，相等元素的相对顺序在排序过程中不会发生变化。

（2）**高效性**：插入排序对于小型数组或大部分已经排序好的数组非常高效，时间复杂度为O(n^2)。

（3）**原地排序**：插入排序是一种原地排序算法，只需要常数级的额外空间。

####选择排序
1、一种不稳定的**原地排序**算法，它的工作原理是每次从待排序的元素中选择最小（或最大）的一个元素，放到已排序序列的末尾，直到整个序列有序。

2、**基本步骤**：
（1）从未排序序列中找到最小（或最大）的元素。

（2）将最小（或最大）的元素与未排序序列的第一个元素交换位置。

（3）在剩余的未排序序列中重复步骤1和步骤2，直至整个序列有序。

```c
// 用于对数组进行选择排序
void selectionSort(int arr[], int n) {
    int i, j, minIndex, temp;
    for (i = 0; i < n - 1; i++) {
        minIndex = i;

        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}
```
3、特点
（1）**不稳定性**：选择排序是一种不稳定的排序算法，相等元素的相对顺序在排序过程中可能发生变化。

（2）**高效性**：选择排序的时间复杂度为O(n^2)，其中n是待排序数组的长度。它对于小型数组或部分有序的数组相对高效。

（3）**原地排序**：选择排序是一种原地排序算法，只需要常数级的额外空间。

###3.3 数组操作算法
####数组翻转
1、数组翻转是一种操作，通过交换数组中元素的位置，将数组中的元素按照相反的顺序重新排列。

2、**基本步骤**：
（1）定义两个指针，一个指向数组的起始位置，另一个指向数组的末尾位置。

（2）交换指针所指向的元素，并将指针向中间移动。

（3）重复步骤2，直至两个指针相遇或交叉。

```c
// 接受一个指向数组的指针和数组的长度作为参数，通过指针操作对数组进行翻转。
void reverseArray(int* arr, int n) {
    int* start = arr;
    int* end = arr + n - 1;

    while (start < end) {
        // 交换两个指针所指向的元素
        int temp = *start;
        *start = *end;
        *end = temp;

        // 移动指针
        start++;
        end--;
    }
}
```
3、特点
（1）**原地操作**：数组翻转是一种原地操作，不需要额外的空间来存储中间结果。

（2）**时间复杂度**：数组翻转的时间复杂度为O(n)，其中n是数组的长度。

（3）**不改变元素的相对顺序**：数组翻转只改变了元素的次序，而没有改变元素之间的相对顺序。

####查找最大元素
1、在给定的一组元素中，找到其中最大的元素。（最小元素同理）

2、**基本步骤**：
（1）初始化一个变量 max，用于存储最大值，将其初始值设为集合中的第一个元素。

（2）从第二个元素开始，遍历整个集合。

（3）如果当前元素大于 max，则将其赋值给 max。

（4）遍历完所有元素后，max 就是集合中的最大元素。

```c
// 用于查找最大元素
int findMax(int arr[], int size) {
    int max = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}
```
3、特点
（1）可以用于任意数量的元素，不受限于特定的数据结构。

（2）只需遍历一次集合即可找到最大元素。

####数组去重
1、数组去重是指从一个数组中删除重复的元素，使得每个元素只出现一次。

2、**基本步骤**：
（1）定义一个新的数组或修改原始数组，用于存储去重后的结果。

（2）遍历原始数组中的每个元素。

（3）检查当前元素是否已经在新数组中存在。

（4）如果不存在，则将该元素添加到新数组中。

（5）最终得到的新数组即为去重后的结果。

```c
// 用于对数组进行去重操作
void removeDuplicates(int arr[], int size) {
    int result[size];
    int index = 0;

    for (int i = 0; i < size; i++) {
        int j;
        for (j = 0; j < index; j++) {
            if (arr[i] == result[j]) {
                break;
            }
        }
        if (j == index) {
            result[index++] = arr[i];
        }
    }

    // 将去重后的结果拷贝回原始数组
    for (int i = 0; i < index; i++) {
        arr[i] = result[i];
    }
}
```
3、特点
（1）去重后的数组元素顺序可能会改变。

（2）去重操作会消耗额外的空间，所以需要注意内存的使用。
